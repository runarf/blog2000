{"componentChunkName":"component---src-templates-posts-page-layout-js","path":"/content/AsyncKotlinJs/","result":{"data":{"mdx":{"id":"49011841-f863-5b4e-8e0e-82efec5f2079","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Asynchronous programming in Kotlin vs in Javascript\",\n  \"date\": \"2020-01-10\",\n  \"type\": \"blog\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar CodeBlock = makeShortcode(\"CodeBlock\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Lets compare a program doing the same thing in two different programming languages, Javascript and Kotlin.\"), mdx(\"p\", null, \"First we need to import dependencies:\"), mdx(CodeBlock, {\n    className: \"javascript\",\n    mdxType: \"CodeBlock\"\n  }, \"const axios = require(\\\"axios\\\")\"), mdx(CodeBlock, {\n    className: \"kotlin\",\n    mdxType: \"CodeBlock\"\n  }, \"\\nimport io.ktor.client.HttpClient\\nimport io.ktor.client.features.json.JsonFeature\\nimport io.ktor.client.request.get\\nimport kotlinx.coroutines.Deferred\\nimport kotlinx.coroutines.async\\nimport kotlinx.coroutines.coroutineScope\\nimport kotlinx.coroutines.runBlocking\\n \\nval client: HttpClient = HttpClient() {\\n    install(JsonFeature)\\n}\\n\"), mdx(\"p\", null, \"Then we create a main function:\"), mdx(CodeBlock, {\n    className: \"javascript\",\n    mdxType: \"CodeBlock\"\n  }, \"\\nconst main = async () => {\\n  await displayPokemonsParallell()\\n  await displayPokemonsSequential()\\n}\\n\"), mdx(CodeBlock, {\n    className: \"kotlin\",\n    mdxType: \"CodeBlock\"\n  }, \"\\nfun main(args: Array<String>): Unit = runBlocking<Unit> {\\n    displayPokemonsParallell()\\n    displayPokemonsSequential()\\n}\\n\"), mdx(\"p\", null, \"First well look at getting the pokemons sequentially.\"), mdx(CodeBlock, {\n    className: \"javascript\",\n    mdxType: \"CodeBlock\"\n  }, \"\\nconst displayPokemonsSequential = async () => {\\n  const firstPokemon = await axios.get(\\\"https://pokeapi.co/api/v2/pokemon/ditto/\\\")\\n  const secondPokemon = await axios.get(\\\"https://pokeapi.co/api/v2/pokemon/1/\\\")\\n \\n  console.log(firstPokemon.data.name)\\n  console.log(secondPokemon.data.name)\\n}\\n\"), mdx(CodeBlock, {\n    className: \"kotlin\",\n    mdxType: \"CodeBlock\"\n  }, \"\\ndata class Pokemon(val name: String)\\n \\nsuspend fun displayPokemonsSequential(): Unit = coroutineScope<Unit> {\\n \\n    val firstPokemon: Pokemon = client.get<Pokemon>(\\\"https://pokeapi.co/api/v2/pokemon/ditto/\\\")\\n    val secondPokemon: Pokemon = client.get<Pokemon>(\\\"https://pokeapi.co/api/v2/pokemon/1/\\\")\\n      \\n    println(firstPokemon)\\n    println(secondPokemon)\\n}\\n\"), mdx(\"p\", null, \"Then in parallell\"), mdx(CodeBlock, {\n    className: \"javascript\",\n    mdxType: \"CodeBlock\"\n  }, \"\\nconst displayPokemonsParallell = async () => {\\n  const firstPokemonPromise = axios.get(\\\"https://pokeapi.co/api/v2/pokemon/ditto/\\\")\\n  const secondPokemonPromise = axios.get(\\\"https://pokeapi.co/api/v2/pokemon/1/\\\")\\n \\n  const firstPokemon = await firstPokemonPromise\\n  const secondPokemon = await secondPokemonPromise\\n \\n  console.log(firstPokemon.data.name)\\n  console.log(secondPokemon.data.name)\\n}\\n\"), mdx(CodeBlock, {\n    className: \"kotlin\",\n    mdxType: \"CodeBlock\"\n  }, \"\\nsuspend fun displayPokemonsParallell(): Unit = coroutineScope<Unit> {\\n      val firstDeferredPokemon: Deferred<Pokemon> = async { client.get<Pokemon>(\\\"https://pokeapi.co/api/v2/pokemon/ditto/\\\") }\\n      val secondDeferredPokemon: Deferred<Pokemon> = async { client.get<Pokemon>(\\\"https://pokeapi.co/api/v2/pokemon/1/\\\") }\\n \\n      val firstPokemon: Pokemon = firstDeferredPokemon.await()\\n      val secondPokemon: Pokemon = secondDeferredPokemon.await()\\n \\n      println(firstPokemon)\\n      println(secondPokemon)\\n  }\\n\"), mdx(\"table\", null, mdx(\"tr\", null, mdx(\"th\", null), mdx(\"th\", null, \"Javascript\"), mdx(\"th\", null, \"Kotlin\")), mdx(\"tr\", null, mdx(\"td\", null, \"Mark a function as asynchronous\"), mdx(\"td\", null, mdx(CodeBlock, {\n    className: \"javascript\",\n    mdxType: \"CodeBlock\"\n  }, \"const displayPokemons = async () => {}\")), mdx(\"td\", null, mdx(CodeBlock, {\n    className: \"kotlin\",\n    mdxType: \"CodeBlock\"\n  }, \"suspend fun displayPokemons(): Unit = coroutineScope {}\"))), mdx(\"tr\", null, mdx(\"td\", null, \"Get pokemons sequantially\"), mdx(\"td\", null, mdx(CodeBlock, {\n    className: \"javascript\",\n    mdxType: \"CodeBlock\"\n  }, \"\\n        const firstPokemon = await axios.get(\\\"https://pokeapi.co/api/v2/pokemon/ditto/\\\")\\n        const secondPokemon = await axios.get(\\\"https://pokeapi.co/api/v2/pokemon/1/\\\")\\n      \".replace(/^ +/gm, ''))), mdx(\"td\", null, mdx(CodeBlock, {\n    className: \"kotlin\",\n    mdxType: \"CodeBlock\"\n  }, \"\\n        val firstPokemon: Pokemon = client.get<Pokemon>(\\\"https://pokeapi.co/api/v2/pokemon/ditto/\\\")\\n        val secondPokemon: Pokemon = client.get<Pokemon>(\\\"https://pokeapi.co/api/v2/pokemon/1/\\\")\\n      \".replace(/^ +/gm, '')))), mdx(\"tr\", null, mdx(\"td\", null, \"Get pokemons in parallell\"), mdx(\"td\", null, mdx(CodeBlock, {\n    className: \"javascript\",\n    mdxType: \"CodeBlock\"\n  }, \"\\nconst firstPokemonPromise = axios.get(\\\"https://pokeapi.co/api/v2/pokemon/ditto/\\\")\\nconst secondPokemonPromise = axios.get(\\\"https://pokeapi.co/api/v2/pokemon/1/\\\")\\n \\nconst firstPokemon = await firstPokemonPromise\\nconst secondPokemon = await secondPokemonPromise\\n\")), mdx(\"td\", null, mdx(CodeBlock, {\n    className: \"kotlin\",\n    mdxType: \"CodeBlock\"\n  }, \"\\nval firstDeferredPokemon: Deferred<Pokemon> = async { client.get<Pokemon>(\\\"https://pokeapi.co/api/v2/pokemon/ditto/\\\") }\\nval secondDeferredPokemon: Deferred<Pokemon> = async { client.get<Pokemon>(\\\"https://pokeapi.co/api/v2/pokemon/1/\\\") }\\n \\nval firstPokemon: Pokemon = firstDeferredPokemon.await()\\nval secondPokemon: Pokemon = secondDeferredPokemon.await()\\n\"), \" \"))), mdx(\"p\", null, \"Doing asynchronous programming in Javascript and Kotlin is similar but also different. The biggest difference is that Javascript by default continues the program when doing an asyncronous call. Kotlin stops when doing an asynchronous call.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"Asynchronous programming in Kotlin vs in Javascript"}}},"pageContext":{"id":"49011841-f863-5b4e-8e0e-82efec5f2079"}}}